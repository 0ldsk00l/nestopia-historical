nes_ntsc 0.1.7 Notes
--------------------
Author : Shay Green <gblargg@gmail.com>
Website: http://www.slack.net/~ant/
Forum  : http://groups.google.com/group/blargg-sound-libs


Overview
--------
This library can emulate NTSC composite video, and also generate an
approximate RGB palette for use in a normal blitter.

To use the NTSC blitter, allocate memory for a nes_ntsc_t object and
call nes_ntsc_init(), then call nes_ntsc_blit as needed when you want to
display a NES NTSC image. You can call nes_ntsc_init() at any time to
change image parameters.

Nes_ntsc_blit() reads NES pixels and writes 16-bit RGB pixels. The NES
pixels are raw palette values (0 to 0x3F) stored in 8-bit unsigned
chars. In_pitch and out_pitch specify the number of *bytes* to get to
the next row of input/output. For example, if your NES rows are 256
pixels wide, in_pitch should be 256. If your output graphics buffer is
640 pixels wide, out_pitch should be 1280 (640 * 2 bytes per pixel).
Out_width and out_height specify the size of the *output* you want
generated.


RGB Palette Generation
----------------------
An RGB palette can be generated or use in a normal blitter, either 64
colors (192 bytes) or including all 8 color emphasis combinations to
result in 512 colors (1536 bytes). The 64-color version matches the
format of the common NES .pal file. In your nes_ntsc_setup_t structure,
point palette_out to a buffer to hold the palette, then call
nes_ntsc_init() (nes_ntsc_init_emph() for the 512-color version). If you
only need the palette and aren't going to be using the NTSC blitter,
pass 0 for the first parameter.


Image Size
----------
There are three main output sizes you can use: minimum, what will fit
within 640 pixels across, and full. Use nes_ntsc_min_out_width to output
just 256 NES pixels per line, the minimum possible without cutting off
active NES pixels. Use nes_ntsc_640_out_width to output as many NES
pixels as will fit within 640 output pixels, which adds around 8 NES
pixels on each side for an overscan border. For the most accurate image,
use nes_ntsc_full_out_width, which displays enough NES pixels to allow
for the full overscan border that the NES video signal contains.

Output widths that leave an overscan border read more than 256 NES
pixels per row. Use *_overscan_left and *_overscan_right to find the
width of the overscan borders for the wider output modes. The overscan
borders should be set to the background color (the first color in the
palette). For example, if you're using nes_ntsc_640_out_width, your NES
pixel buffer will need to be nes_ntsc_640_in_width pixels wide, each
line consisting of nes_ntsc_640_overscan_left overscan pixels, 256
active NES pixels, and nes_ntsc_640_overscan_right overscan pixels.

The library does not vertically double the image. For proper aspect
ratio, the image generated by the library should be doubled vertically.
This can be done in software, as the demo does, done in a custom blitter
for more efficiency (see below), or using a modern video card's hardware
rescaling. On a TV pixels never have crisp edges, so simply doubling
scanlines doesn't give a very authentic image. I've found reducing the
doubled scanline's brightness to 75% looks significantly better without
darkening the image much. To drop brightness to 75%, calculate 25%
brightness using simple bit shifting and masking, then subtract this
from the original.


Burst Phase
-----------
The burst_phase parameter to nes_ntsc_blit should generally toggle
values between frames, i.e. 0 on first call to nes_ntsc_blit, 1 on
second call, 0 on third call, 1 on fourth, etc. If merge_fields is
enabled (see below), you should always pass 0. Read further for more
detailed operation.

If you're using nes_ntsc_blit to do partial screen updates, burst_phase
should be calculated as (burst_phase + row) % 3, where row is the
starting row (0 through 239). For example, if burst_phase is 1 for the
current frame and you make two calls to nes_ntsc_blit to blit rows 0 to
100, then rows 101 to 239, for the first call you should pass 1 for
burst_phase, and for the second call you should pass 0 for burst_phase:
(1 + 101) % 3 = 0.

For more accurate burst_phase operation, it should be adjusted at the
beginning of a frame based on the length of scanline 20: if 341 clocks
(normal), burst_phase = (burst_phase + 1) % 3, otherwise burst_phase =
(burst_phase + 2) % 3 (for shorter 340 clock scanline).

The included test ROMs verify proper burst_phase implementation. They
must pass in order; an earlier failing test means that later tests will
give meaningless results. The first two tests will pass with either
method of burst_phase handling described above; the third will only pass
with the more accurate handling. The tests flash sets of dots quickly
with the dot color being the only important aspect.

1.line_phase.nes - Tests for proper burst_phase on each scanline. All
dots on screen should be the same color.

2.frame_phase.nes - Tests for proper burst_phase toggling between
frames. Each row of dots should alternate between the same two colors
(if merge_fields is set to 1, they should all be the same color).

3.special_frame_phase.nes - Tests for proper burst_phase incrementing
between frames when $2001 rendering is enabled late in the frame. Each
rectangle of dots should be one color, and there should be three
different colors of rectangles (if merge_fields is set to 1, each
rectangle should be made of three colors of dots). There is a visual
glitch near the top of the screen for the first line of dots; this is
unrelated the test and should be ignored.


Flickering
----------
The image on a NES flickers between two different pixel artifact
patterns at a steady rate, making it appear stable. For an emulator to
duplicate this effect, its frame rate must match the host monitor's
refresh rate, it must be synchronizing to the refresh (vsync), and it
must not be skipping any frames. If any of these don't hold, the image
will probably flicker much more than a NES would on a TV. It is
important that you play around with these factors to get a good feel for
the issue, and document it clearly for end-users, otherwise they will
have difficulty getting an authentic image.

The library includes a partial workaround for this issue, for the cases
where all the conditions can't be met. When merge_fields is set to 1,
nes_ntsc_blit does the equivalent of blitting the image twice with the
two different phases and then mixes them together, but without any
performance impact. The result is similar to what you'd see if the
monitor's refresh rate were the same as the emulator's. It does reduce
the shimmer effect when scrolling, so it's not a complete solution to
the refresh rate issue.

The merge_fields option is also useful when taking a snapshot. If you
capture without merge_fields set to 1, you'll only get the even or odd
artifacts, which will make the image look more grainy than when the
emulator is running. Again, play around with this to get an idea of the
difference. It might be best to simply allow the user to choose when to
enable this option.

Note that when you have merge_fields set to 1, you should always pass 0
for the burst_phase parameter to nes_ntsc_blit. If you don't, you'll
still get some flicker.


Custom Blitter
--------------
The standard nes_ntsc_blit function outputs in 16-bit RGB and isn't
optimized for any particular platform. You can write your own blitter to
use in place of this, allowing customization of how NES pixels are
obtained (you might want to run through a palette first), the format of
output pixels (15, 16, or 32-bit RGB), optimizations for your platform,
and additional effects like efficient scanline doubling during blitting.

Macros are included in nes_ntsc.h for writing your blitter so that your
code can be carried over without changes to improved versions of the
library. The default blitter at the end of nes_ntsc.c shows how to use
the macros. Be sure to your custom blitter in a separate source file,
rather than modifying the library source file directly.

For an example of a flexible blitter written in C++ and optimized for
the x86 architecture, refer to Nestopia 1.28's (forthcoming)
NstVideoFilterNtsc2.hpp.


Color Emphasis Bits
-------------------
The color emphasis bits stored in the top three bits of the PPU $2001
register are optionally supported by using nes_ntsc_emph_t and
nes_ntsc_init_emph() in place of nes_ntsc_t and nes_ntsc_init(). The
standard blitter doesn't support emphasis bits, so you must write a
custom blitter. In your custom blitter, place the emphasis bits into the
7th-9th bits of the palette index: (ppu2001 << 1 & 0x1C0) |
(palette_index & 0x3F).


Limitations
-----------
The library's horizontal rescaling is too wide by about 3% in order to
allow a much more optimal implementation. This means that a 256 pixel
wide NES image should appear as 581 output pixels, but with this library
appears as 602 output pixels. TV aspect ratios probably vary by this
much anyway. If you really need unscaled output, contact me and I'll see
about adding it.

The image quality is not as good as on a TV. I hope to improve this
eventually.


Thanks
------
Thanks to NewRisingSun for his original code, which was a starting point
for me learning about NTSC video and decoding. Thanks to the Nesdev
forum for feedback and encouragement. Thanks to byuu (bsnes author) and
pagefault (ZSNES team) for integrating a SNES version of this in their
emulators. Thanks to Martin Freij (Nestopia author) for using an earlier
development version in Nestopia and for feedback about the custom
blitter interface.
