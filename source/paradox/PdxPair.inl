//////////////////////////////////////////////////////////////////////////////////////////////
//
// Paradox Library - general purpose C++ utilities
//
// Copyright (C) 2003 Martin Freij
//
// This file is part of Paradox Library.
// 
// Paradox Library is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
// 
// Paradox Library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Paradox Library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef PDXPAIR_H 
#error Do not include PdxPair.inl directly!
#endif

//////////////////////////////////////////////////////////////////////////////////////////////
// Throw in the pair
//////////////////////////////////////////////////////////////////////////////////////////////

namespace PDX
{
	template<class T,class U> 
	inline PDXPAIR<T,U> MakePair(const T& x,const U& y)
	{
		return PDXPAIR<T,U>(x,y);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Equal?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator == (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return (x.First() == y.First() && x.Second() == y.Second());
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Not equal?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator != (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return !(x == y);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Less than?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator < (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return (x.First() < y.First() || !(y.First() < x.First()) && x.Second() < y.Second());
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Greater than?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator > (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return (y < x);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Less or equal than?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator <= (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return !(y < x);
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Greater or equal than?
//////////////////////////////////////////////////////////////////////////////////////////////

template<class T,class U,class V,class W> 
inline BOOL operator >= (const PDXPAIR<T,U>& x,const PDXPAIR<V,W>& y)
{
	return !(x < y);
}

